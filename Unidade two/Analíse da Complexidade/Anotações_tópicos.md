# Complexidades de Tempo dos Algoritmos
# Algoritmos de Ordenação

## Bubble Sort
    - Melhor caso: O(n), lista ordenada.
    - Pior caso: O(n²),  lista ordenada em ordem decrescente.

## Insertion Sort
    - Melhor caso: O(n), lista ordenada.
    - Pior caso: O(n²), lista ordenada em ordem decrescente.

## Selection Sort
    - Melhor caso: O(n²), independente da organização inicial dos dados.
    - Pior caso: O(n²), independente da organização inicial dos dados.

## Merge Sort
    - Melhor caso: O(n log n), independente da organização inicial dos dados.
    - Pior caso: O(n log n), independente da organização inicial dos dados.

## Quick Sort
    - Melhor caso: O(n log n), o array dividido em duas partes quase iguais.
    - Pior caso: O(n²), a superioridade e inferioridade.

## Shell Sort
    - Melhor caso: O(n log n), lista ordenada.
    - Pior caso: O(n²), lista ordenada em ordem decrescente.

## Gnome Sort
    - Melhor caso: O(n), lista ordenada.
    - Pior caso: O(n²), lista ordenada em ordem decrescente.
  
# Algoritmos de Busca

## Busca Linear
    - Melhor caso: O(1), quando o elemento procurado está na primeira posição.
    - Pior caso: O(n), quando o elemento procurado está na última posição ou não está presente.
 
## Busca Binária
    - Melhor caso: O(1), quando o elemento procurado está na posição média.
    - Pior caso: O(log n), quando o elemento procurado está em uma das extremidades ou não está presente.

## Busca por Interpolação
    - Melhor caso: O(1), quando o elemento procurado na posição calculada na primeira iteração.
    - Pior caso: O(n), elementos não estão uniformemente distribuídos.

## Jump Search
    - Melhor caso: O(1), quando o elemento procurado está na primeira posição.
    - Pior caso: O(√n), quando o elemento procurado está na última posição ou não está presente.

## Busca Exponencial
    - Melhor caso: O(1), quando o elemento procurado está na primeira posição.
    - Pior caso: O(log n), quando o elemento procurado está em uma das extremidades ou não está presente.
